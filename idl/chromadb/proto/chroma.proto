syntax = "proto3";

package chroma;

option go_package = "github.com/chroma-core/chroma/go/pkg/proto/coordinatorpb";

message Status {
  string reason = 1;
  int32 code = 2; // TODO: What is the enum of this code?
}

// Types here should mirror chromadb/types.py
enum Operation {
    ADD = 0;
    UPDATE = 1;
    UPSERT = 2;
    DELETE = 3;
}

enum ScalarEncoding {
    FLOAT32 = 0;
    INT32 = 1;
}

message Vector {
    int32 dimension = 1;
    bytes vector = 2;
    ScalarEncoding encoding = 3;
}

enum SegmentScope {
    VECTOR = 0;
    METADATA = 1;
}

message FilePaths {
    repeated string paths = 1;
}

message Segment {
    string id = 1;
    string type = 2;
    SegmentScope scope = 3;
    optional string collection = 5;
    optional UpdateMetadata metadata = 6;
    map<string,FilePaths> file_paths = 7;
}

message Collection {
  string id = 1;
  string name = 2;
  optional UpdateMetadata metadata = 4;
  optional int32 dimension = 5;
  string tenant = 6;
  string database = 7;
  int64 log_position = 8;
  int32 version = 9;
}

message Database {
    string id = 1;
    string name = 2;
    string tenant = 3;
}

message Tenant {
    string name = 1;
}

message UpdateMetadataValue {
    oneof value {
        string string_value = 1;
        int64 int_value = 2;
        double float_value = 3;
    }
}

message UpdateMetadata {
    map<string, UpdateMetadataValue> metadata = 1;
}

// Represents an operation the user submits
message OperationRecord {
    string id = 1;
    optional Vector vector = 2;
    optional UpdateMetadata metadata = 3;
    Operation operation = 4;
}

/* Metadata Reader Interface */

service MetadataReader {
    rpc GetMetadata(GetMetadataRequest) returns (GetMetadataResponse) {}
}

message GetMetadataRequest {
    Where where = 1;
    WhereDocument where_document = 2;
    repeated string ids = 3;
    optional int32 limit = 4;
    optional int32 offset = 5;
}

enum WhereListType {
    IN = 0;
    NIN = 1;
}

enum WhereChildrenType {
    AND = 0;
    OR = 1;
}

// A `Where` clause for filtering metadata. A `Where` clause is a tree of
// `Where` clauses, where each node is exactly one of:
// - A leaf node with a key, a list of values, and a list type (IN or NIN)
// - An branch node with a list of children and a children type (AND or OR)
message Where {
    // Metadata key
    string key = 1;
    // Allowed or disallowed metadata values
    repeated string values = 2;
    // Whether we're filtering IN or NIN `values`
    WhereListType list_type = 3;
    // Children of this `Where` clause
    repeated Where children = 4;
    // Whether children should be ANDed or ORed
    WhereChildrenType children_type = 5;
}

message WhereDocument {
    repeated string contains = 1;
    repeated string not_contains = 2;
}

message GetMetadataResponse {
    repeated MetadataEmbeddingRecord records = 1;
}

message MetadataEmbeddingRecord {
    string id = 1;
    UpdateMetadata metadata = 2;
}

/* Vector Reader Interface */

service VectorReader {
    rpc GetVectors(GetVectorsRequest) returns (GetVectorsResponse) {}
    rpc QueryVectors(QueryVectorsRequest) returns (QueryVectorsResponse) {}
}

message GetVectorsRequest {
    repeated string ids = 1;
    string segment_id = 2;
}

message GetVectorsResponse {
    repeated VectorEmbeddingRecord records = 1;
}

message VectorEmbeddingRecord {
    string id = 1;
    Vector vector = 3; // TODO: we need to rethink source of truth for vector dimensionality and encoding
}

message QueryVectorsRequest {
    repeated Vector vectors = 1;
    int32 k = 2;
    repeated string allowed_ids = 3;
    bool include_embeddings = 4;
    string segment_id = 5;
    // TODO: options as in types.py, its currently unused so can add later
}

message QueryVectorsResponse {
    repeated VectorQueryResults results = 1;
}

message VectorQueryResults {
    repeated VectorQueryResult results = 1;
}

message VectorQueryResult {
    string id = 1;
    float distance = 3;
    optional Vector vector = 4;
}